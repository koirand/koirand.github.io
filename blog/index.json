[
    {
        "ref": "https://koirand.github.io/blog/2018/textlint/",
        "title": "ブログの記事をtextlintで校正してみた",
        "section": "blog",
        "date" : "2018.11.11",
        "body": " このブログを書いていて、記事を公開してしまってから間抜けな誤字脱字に気づくことが度々あった。慌てて修正してPushして確認すると、また別のミスを見つけてしまって、何度も修正する羽目になる。個人ブログなので神経質になる必要はないがミスを見つけてしまうと何となく気になって修正してしまう。流石に虚しいので文章校正の仕組みを入れることにした。今はVimというテキストエディタで記事を書いているので、Vim上で文書校正をしてみた。\ntextlintのインストール 文章校正ツールである textlint インストール。ルールは種類が多すぎて正直どれを入れれば良いのか迷う。とりあえず無難そうな 技術文書向けのtextlintルールプリセットと、Webエンジニア向けの辞書 をインストールしてみた。\n$npm install -g textlint $npm install -g textlint-rule-preset-ja-technical-writing textlint-rule-spellcheck-tech-word textlintの設定 ホームディレクトリに.textlintrcを作成する。デフォルトだと一文の長さが100文字を越えると警告が表示されるが、100文字だとURLなどを記載するとすぐに超えてしまうので200文字で上書きした。\n{ \u0026#34;rules\u0026#34;: { \u0026#34;preset-ja-technical-writing\u0026#34;: { \u0026#34;sentence-length\u0026#34;: { \u0026#34;max\u0026#34;: 200 } }, \u0026#34;spellcheck-tech-word\u0026#34;: true } } Vimプラグインの導入 vimrcの設定例は以下。Lintエンジンの w0rp/ale と、ステータスラインをカスタマイズする itchyny/lightline.vimを使っている。\n\u0026#34; alelet g:ale_linters = { \\ \u0026#39;markdown\u0026#39;: [\u0026#39;textlint\u0026#39;] \\}\u0026#34; lightlinelet g:lightline = { \\ \u0026#39;active\u0026#39;: { \\ \u0026#39;left\u0026#39;: [ \\ [\u0026#39;mode\u0026#39;, \u0026#39;paste\u0026#39;], \\ [\u0026#39;readonly\u0026#39;, \u0026#39;filename\u0026#39;, \u0026#39;modified\u0026#39;, \u0026#39;ale\u0026#39;], \\ ] \\ }, \\ \u0026#39;component_function\u0026#39;: { \\ \u0026#39;ale\u0026#39;: \u0026#39;ALEGetStatusLine\u0026#39; \\ }\\ } 結果 こんな感じで警告してくれるようになった。行番号の箇所に警告マークが表示され、そこにカーソルを合わせると警告の内容が一番下に表示される。また警告の総数がステータスラインに表示されている。便利。 "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/pulp-search2/",
        "title": "HUGOテーマ(pulp)の全文検索をあいまい検索に変更した",
        "section": "blog",
        "date" : "2018.10.31",
        "body": "前回の記事「HUGOテーマ(pulp)に全文検索機能を付けた」でブログのテーマに全文検索機能を追加したが、HUGOのテーマとして配布し辛いという課題があった。lunr.js単体だけだとスペースで単語を区切らない言語での検索ができない。日本語も然り。トークナイズ用のプラグインを使えば正しく分かち書きされて検索できるようになるが、基本的にプラグインは特定の言語に特化したものなので、不特定な言語に対応できない。\nこの問題の解決方法としては以下２つが考えられる。\n N-gramを使う インデックスを使わない普通の検索にする  まずはN-gram方式を試してみた。lune.jsのトークナイズプラグインを探しても見つからなかったが、 Pull Request #63 olivernn/lunr.js　に紹介されているようにN-gramでの分割処理を実装してtokenizerに登録すればできる。\nvar myNgramTokenizer = function () { lunr.tokenizer = function (obj) { // ngram implementation  } } idx.use(myNgramTokenizer)  検索クエリも同様にN-gramで分割処理をしてあげれば検索ができる。ただ単純なN-gramだけでは検索精度がいまひとつだった。第5回 N-gramのしくみ：検索エンジンを作る｜gihyo.jp … 技術評論社 にも記載されている通り、分割した文字列片がそれぞれバラバラの箇所でヒットしてしまう問題がある。検索精度を高めるためには、ヒットした文字列片の出現位置を見てあげる必要があるようだ。\nN-gramの実装はなかなか大変そうだったので、インデックスはあきらめてFuse.jsというあいまい検索のライブラリを使うことにした。Fuse.jsのデフォルトのオプションだと本文の先頭32文字しかヒットしないが、Hugo JS Searching with Fuse.js で紹介されている通り、tokenizeオプションを有効にすると全文検索可能になる。色々オプションを試して以下に落ち着いた。\nvar options = { shouldSort: true, tokenize: true, matchAllTokens: true, threshold: 0.3, minMatchCharLength: 5, keys: [\u0026#39;title\u0026#39;, \u0026#39;body\u0026#39;] }  検索精度は上々、不特定な言語でも問題ないはず。しかもあいまい検索なので若干スペルを間違えても検索ができる。ただしインデックスを使っていないのでパフォーマンスは悪い。前回と同じく Skycoin社のブログデータを使って試してみたら約150件の記事でも結構検索がカクついた。一旦はこれで運用するが、N-gramをもう少し頑張ったほうが良さそうだ。全文検索の道のりは思ったより険しい。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/pulp-search/",
        "title": "HUGOテーマ(pulp)に全文検索機能を付けた",
        "section": "blog",
        "date" : "2018.10.08",
        "body": " 先日作ったpulpというHUGOのテーマに全文検索機能を付けてみた。タグやカテゴリで分類するのが個人的に面倒臭いと思ってしまうので、何もしなくても本文が検索できればいいなと思っていた。しっかり作るならElasticSearchやAlgoliaを使うんだろうけど、そうするとThemeとして配布しづらくなるし、個人用途としてはそこまでの機能はいらないのでフロントエンドだけで完結する方法を模索した。\nデモ 記事をJSONで取得できるようにする まずは、HugoでJSONを出力 | Celeumu を参考にしつつブログの記事をJSONで取得できるようにした。config.tomlに以下を追記すると、拡張子が.jsonのテンプレートをHUGOがテンプレートとして見てくれるようになった。\n[outputs] section = [\u0026#34;JSON\u0026#34;, \u0026#34;HTML\u0026#34;] その上でlayouts/_default/list.json を作成すると、http://hostname/section/index.json といったURLでいとも簡単にセクションのデータをJSONで引っこ抜くことができるようになる。このブログの場合だと、https://koirand.github.io/blog/index.json からデータが取得できる。\n[{{ range $index, $page := .Pages }}{{ if ne $index 0 }},{{ end }} { \u0026quot;ref\u0026quot;: \u0026quot;{{ $page.Permalink }}\u0026quot;, \u0026quot;title\u0026quot;: {{ $page.Title | jsonify }}, \u0026quot;section\u0026quot;: \u0026quot;{{ $page.Section }}\u0026quot;, \u0026quot;date\u0026quot; : {{ $page.Date.Format \u0026quot;2006.01.02\u0026quot; | jsonify }}, \u0026quot;body\u0026quot;: {{ $page.Plain | jsonify }} } {{ end }}]  検索処理の実装 検索処理は hugo + gruntjs + lunrjs = search にlunr.jsを使ったサンプルコードを掲載してくれている人がいて、ほぼこのままで動いた。このサンプルコードをベースに以下のカスタマイズを加えた。具体的な変更内容は Add full-text search function by koirand · Pull Request #3 · koirand/pulp を参照。\n 検索結果に本文を表示 日本語での検索対応 キーワードのハイライト  検索結果に本文を表示 本文でキーワードにヒットした箇所の前後50文字を検索結果に表示した。複数のキーワードがスペース区切りで入力された場合は先頭のキーワードだけを使っている。また、タイトルのみにヒットした場合は、本文の先頭100文字を表示している。(恐らくもっと良いやり方がある)\n日本語での検索対応 標準のlunr.jsだとスペースを単語の区切りとみなすのか日本語を検索できないので、MihaiValentin/lunr-languages: A collection of languages stemmers and stopwords for Lunr Javascript library を使う必要がある。READMEには書いてないが、日本語に対応させる場合は同封されているtinyseg.jsも読み込む必要があった。\nキーワードのハイライト キーワードのハイライトは mark.js – JavaScript keyword highlight を使うと簡単だった。\n感想 たまに一部の単語が検索にヒットしないものの、概ねちゃんと検索できてるしサクサクで良い感じ。ページの数が増えてくるとパフォーマンス落ちたりするのかなと、試しに Skycoin社のブログデータ のリポジトリをクローンしてこのテーマを適用してみたが普通にサクサク動いたので個人サイトであれば大丈夫だろう。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/async-await/",
        "title": "Promiseとasync/awaitをちゃんと理解する",
        "section": "blog",
        "date" : "2018.10.01",
        "body": " JavaScriptといえばコールバックだが、最近は基本的に非同期関数はPromiseで実装してasync/awaitするのがトレンドらしい。もし使いたい関数がPromiseをサポートしていない場合は、自分でPromiseにラップするのが良いとのこと。この辺の知識が若干怪しかったので、実際に一からやってみた。\nコールバック方式 まずは、適当に従来のコールバック方式の非同期関数を書いてみる。\n// コールバック方式による非同期関数 function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== \u0026#39;number\u0026#39; || typeof(y) !== \u0026#39;number\u0026#39;) { callback(new Error(\u0026#39;Invalid parameter!\u0026#39;), null) return } callback(null, x + y) }, 1000) } // 実行 sum(1, 2, (err, result) =\u0026gt; { if (err) { console.log(err) return } console.log(\u0026#39;result:\u0026#39;, result) })  sum関数は足し算をするだけの関数だが、1秒もかかってしまう。時間がかかるので非同期で動くようになっている\u0026hellip;ということにする。これを実行すると1秒後にresult: 3が出力される。引数に数値以外が指定された場合は以下のエラーが出力される。\nError: Invalid parameter! at Timeout.setTimeout [as _onTimeout] (/xxx/sandbox/nodejs/1.callback.js:4:16) at ontimeout (timers.js:498:11) at tryOnTimeout (timers.js:323:5) at Timer.listOnTimeout (timers.js:290:5)  Promise方式 次に、先ほどのsum関数をPromiseでラップする。\n// コールバック方式による非同期関数(さっきと同じもの) function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== \u0026#39;number\u0026#39; || typeof(y) !== \u0026#39;number\u0026#39;) { callback(new Error(\u0026#39;Invalid parameter!\u0026#39;), null) return } callback(null, x + y) }, 1000) } // Promiseでラップ function promiseSum (x, y) { return new Promise((resolve, reject) =\u0026gt; { sum(x, y, (err, result) =\u0026gt; { if (err) { reject(err) return } resolve(result) }) }) } // 実行 promiseSum(1, 2).then(result =\u0026gt; { console.log(\u0026#39;result:\u0026#39;, result) }).catch(err =\u0026gt; { console.log(err) })  これがいわゆる「Promiseでラップする」ということ。これを実行しても先ほどと同様に1秒後にresult: 3が出力される。\nコールバック方式とPromise方式の比較 コールバック方式とPromise方式の実行コードを並べてみる。\n// コールバック方式 sum(1, 2, (err, result) =\u0026gt; { if (err) { console.log(err) return } console.log(\u0026#39;result:\u0026#39;, result) }) // Promise方式 promiseSum(1, 2).then(result =\u0026gt; { console.log(\u0026#39;result:\u0026#39;, result) }).catch(err =\u0026gt; { console.log(err) })  コールバック方式の場合は、関数の仕様に合わせて例外処理する必要がある。今回だと「コールバック関数の第一引数でエラーを受け取る」という仕様だ。それがPromiseでラップすることにより、どんな関数でも同じ方法(catch)で例外処理ができる。これはPromise方式のメリットだと感じた。可読性についてはどちらも変わらないと感じる。\n非同期関数を順番に実行する 次に、1から4の数字を全て足し合わせてみる。sum関数は2つの数字しか受け取れないので、1,2の足し算の結果と3を足して、その結果と4を足すという風に順次処理を行う。それぞれ以下のようなコードになる。\nコールバック方式 // コールバック方式による非同期関数 function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== \u0026#39;number\u0026#39; || typeof(y) !== \u0026#39;number\u0026#39;) { callback(new Error(\u0026#39;Invalid parameter!\u0026#39;), null) return } callback(null, x + y) }, 1000) } // 実行 sum(1, 2, (err, result) =\u0026gt; { if (err) { console.log(err) return } sum(result, 3, (err, result) =\u0026gt; { if (err) { console.log(err) return } sum(result, 4, (err, result) =\u0026gt; { if (err) { console.log(err) return } console.log(\u0026#39;result:\u0026#39;, result) }) }) })  これを実行すると、足し算を３回行なっているので、３秒待ったあとにresult: 10が出力される。良くコールバック地獄やネスト地獄と言われて問題になっているが、この程度だとコールバック方式でもそこまで地獄感は感じない。地獄を味わっている人たちはどれくらい激しいネストをしているんだろうか。\nPromise方式 // コールバック方式による非同期関数 function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== \u0026#39;number\u0026#39; || typeof(y) !== \u0026#39;number\u0026#39;) { callback(new Error(\u0026#39;Invalid parameter!\u0026#39;), null) return } callback(null, x + y) }, 1000) } // Promiseでラップ function promiseSum (x, y) { return new Promise((resolve, reject) =\u0026gt; { sum(x, y, (err, result) =\u0026gt; { if (err) { reject(err) return } resolve(result) }) }) } // 実行 promiseSum(1, 2).then(result =\u0026gt; { return promiseSum(result, 3) }).then(result =\u0026gt; { return promiseSum(result, 4) }).then(result =\u0026gt; { console.log(\u0026#39;result:\u0026#39;, result) }).catch(err =\u0026gt; { console.log(err) })  このコードを実行した場合も、３秒待ったあとにresult: 10が出力される。Promise方式だと、メソッドチェイン的な書き方で順番に実行でき、ネストは浅くなる。またPromise方式のもうひとつのメリットとして、try catch的な例外処理ができる。個別に例外を拾いたい場合は、以下のようにthen関数の第二引数に例外処理を書くことができる。\n// 数値以外を引数に指定して故意にエラーを発生させる promiseSum(\u0026#39;x\u0026#39;, 2).then(result =\u0026gt; { return promiseSum(result, 3) }, () =\u0026gt; { console.log(\u0026#39;Error handling ...\u0026#39;) }).then(result =\u0026gt; { return promiseSum(result, 4) }).then(result =\u0026gt; { console.log(\u0026#39;result:\u0026#39;, result) }).catch(err =\u0026gt; { console.log(err) })  この実行結果は以下となる。\u0026rsquo;Error handling\u0026hellip;\u0026lsquo;を出力したあとcatchに飛んでいるのがわかる。\nError handling ... Error: Invalid parameter! at Timeout.setTimeout [as _onTimeout] (/xxx/sandbox/nodejs/5.secencial-promise2.js:4:16) at ontimeout (timers.js:498:11) at tryOnTimeout (timers.js:323:5) at Timer.listOnTimeout (timers.js:290:5)  async/await方式 冒頭に書いた通り、最近はasync/awaitを使うのがトレンドだ。先ほどのPromise方式を async/awaitで書き換えると以下のコードになる。\n// コールバック方式による非同期関数 function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== \u0026#39;number\u0026#39; || typeof(y) !== \u0026#39;number\u0026#39;) { callback(new Error(\u0026#39;Invalid parameter!\u0026#39;), null) return } callback(null, x + y) }, 1000) } // Promiseでラップ function promiseSum (x, y) { return new Promise((resolve, reject) =\u0026gt; { sum(x, y, (err, result) =\u0026gt; { if (err) { reject(err) return } resolve(result) }) }) } // 実行 (async () =\u0026gt; { try { let result; result = await promiseSum(1, 2) result = await promiseSum(result, 3) result = await promiseSum(result, 4) console.log(\u0026#39;result:\u0026#39;, result) } catch (err) { console.log(err) } })()  このコードを実行した場合も3秒待ったあとにresult: 10が出力される。Promise関数にawaitを付けることで処理の完了を待ってくれる。awaitはasyncを付けたfunctionの中だけで使えるというルールがあるので即時関数を使わないといけない点はイマイチだが、コールバックを使わずに同期処理が書けるので可読性が高いと感じる。普通にtry catchで例外処理できるのもポイント高い。ちなみに先ほどのように個別で例外を拾う場合は以下のようになる。\n(async () =\u0026gt; { try { let result; // 数値以外を引数に指定して故意にエラーを発生させる  result = await promiseSum(\u0026#39;x\u0026#39;, 2).catch(err =\u0026gt; { console.log(\u0026#39;Error handling ...\u0026#39;) }) result = await promiseSum(result, 3) result = await promiseSum(result, 4) await console.log(\u0026#39;result:\u0026#39;, result) } catch (err) { console.log(err) } })()  このように、catchで個別に例外を拾うことができる。コールバック完全駆逐\u0026hellip;とまでは行かないようだ。\nasync/await方式でのテスト 昔は、非同期処理をテストするにはco-mocha等を使った気がするが、最近はmochaでasync/awaitが使えるようだ。以下のようなテストコードになる。\ndescribe(\u0026#39;asunc/await test\u0026#39;, () =\u0026gt; { it(\u0026#39;1 + 2 = 3 \u0026#39;, async () =\u0026gt; { const result = await promiseSum(1, 2) assert.strictEqual(result, 3) }) it(\u0026#39;数字以外が入力されるとエラー\u0026#39;, async () =\u0026gt; { let f = () =\u0026gt; {} try { const result = await promiseSum(\u0026#39;x\u0026#39;, 2) } catch (err) { f = () =\u0026gt; {throw err} } finally { assert.throws(f, \u0026#39;Invalid parameter!\u0026#39;) } }) }) "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/blog-auto-deploy/",
        "title": "ブログ(HUGO)のビルドとデプロイをCircleCIで自動化した",
        "section": "blog",
        "date" : "2018.09.30",
        "body": " このブログはHUGO(ヒューゴ)というブログ構築のためのフレームワークを使っている。HUGOで記事を作成する手順はWordPressなどのブログサイトとは異なり、PC上で静的なHTMLやCSSを生成してから、それをWebサーバにアップロードする必要がある。このブログの場合はGitHub Pagesを使っているので、Webサーバを用意しなくてもGitHubにPushすれば公開される仕組みになっているが、いずれにせよ一手間がかかる。これまでは Host on GitHub | Hugo を参考にサイトの生成とGitHubへのPushをシェルスクリプトで自動化していたが、それだったらCIツール使えばいいじゃんってことで、CircleCIでブログのデプロイを自動化することにした。\n自動化の過程 ブログの生成元となるリポジトリは非公開にしたかったのでBitbucketを使っている(GitHubはプライベートリポジトリが有料なので)。Hugo + Bitbucket + CircleCI で GitHub Pages に自動デプロイ | shotarok\u0026rsquo;s Tech Blog で既に同じ構成で自動化している人がいたのでこれを参考に構築した。ただし設定ファイルがCircleCI 1.0のものだったので、 Auto Deploy Hugo by Circle CI 2.0 - taikii blog を見ながらCircle CI 2.0を使った設定にした。Circle CIからGitHubにSSHアクセスする必要があるので、事前に鍵ペアを作成して、公開鍵をGitHubに秘密鍵をCircle CIにそれぞれ登録しておく必要があった。あとデプロイ結果をメールで確認するのが面倒だったので、CircleCI | Slack App ディレクトリ を使ってSlackで通知するようにした。\n.circleci/config.yml version:2jobs:build:docker:-image:cibuilds/hugo:latestenvironment:TZ:Asia/Tokyoworking_directory:~/blogsteps:-checkout-run:name:\u0026#34;Setting for Git\u0026#34;command:| git config --global user.name \u0026#34;koirand\u0026#34; git config --global user.email \u0026#34;koirand.jp@gmail.com\u0026#34;-run:name:\u0026#34;Up to date themes\u0026#34;command:| git submodule sync git submodule update --init --recursive-run:name:\u0026#34;Get GitHub repository\u0026#34;command:gitclonegit@github.com:koirand/koirand.github.io.gitpublic-run:name:\u0026#34;Build \u0026amp; Push\u0026#34;command:| hugo cd public git add . git commit -m \u0026#34;rebuilding site `date \u0026#39;+%Y-%m-%d\u0026#39;`\u0026#34; git push origin master ビルド結果はこんな感じ。14秒くらいかかった。 "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/pulp/",
        "title": "HUGOのオリジナルテーマ(pulp)を作った",
        "section": "blog",
        "date" : "2018.09.29",
        "body": " このブログはHUGO(ヒューゴ)というブログ構築のためのフレームワークを使っている。HUGOはWordPressなどのブログサイトとは異なり、PC上で記事を書いてそれをHUGOを使って静的なHTMLやCSSを生成してくれる仕組みになっている。従ってWebサーバがあればどこでもアップロードして公開できる。\n The world’s fastest framework for building websites | Hugo\n 今回作ったのは、そのHUGOでHTMLやCSSを生成する際に使われるデザインテーマ。最近フロントエンドの画面を久しく作って無かったので、思い出しがてら作ってみることにした。「HUGO 自作テーマ」とかでググると作り方を解説してくれているサイトがいくつもあるし、公式ドキュメントに掲載されている動画が結構わかりやすいので、作り方については困らなかった。ちなみにこのブログはそのテーマを適用している。またURLを見ての通りGitHub Pagesで公開している。\nソースコード koirand/pulp: Pulp is a theme of Hugo framework for realize simple and readable personal blogs.\nスクリーンショット 特徴  色数を少なくして読みやすさを意識 表示媒体を選ばないデザイン 日本語対応 CSSやJSのカスタマイズ可能 コードのシンタックスハイライト対応   OGP,Twitter Card対応   一応SEOを意識して作ったけどまだ効果は不明 GoogleAnalyticsにも対応  今後やりたいこと  全文検索ができるようになるといいかな しばらく自分のブログで運用して、問題なさそうだったらHUGO公式サイトに掲載してもらう予定  "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/line-login-with-springboot/",
        "title": "SpringbootでLINEのOAuth2ログインを試した",
        "section": "blog",
        "date" : "2018.09.24",
        "body": " タイトルの通り、いわゆる「LINEでログイン」を試してみた時のメモ。\nソースコード koirand/springboot-line-login: LINE login with Springboot Sample\nOAuth2での認証方法  第1回：Spring Security 5でサポートされるOAuth 2.0 LoginをSpring Bootで使ってみる\n 主にこの記事にOAuth2クライアントの実装を行った。OAuth2でログインするためには、spring-security-oauth2-clientモジュールを使う。OpenID Connectでの認証を行う場合は加えてspring-security-oauth2-joseが必要になるが、今回はOAuth2のみなので入れなかった。\n\u0026lt;!-- OAuth2 authentication--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-oauth2-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; application.properties に以下の通りLINE用の設定を記載する。clientIDとclientSeretはLINE Developersで取得したものに書き換える。\n# Settings for LINE login spring.security.oauth2.client.registration.line.clientId={Set your client id} spring.security.oauth2.client.registration.line.clientSecret={Set your client secret} spring.security.oauth2.client.registration.line.authorizationGrantType=authorization_code spring.security.oauth2.client.registration.line.redirectUriTemplate={baseUrl}/login/oauth2/code/{registrationId} spring.security.oauth2.client.registration.line.scope=profile spring.security.oauth2.client.registration.line.clientName=LINE spring.security.oauth2.client.provider.line.authorizationUri=https://access.line.me/oauth2/v2.1/authorize spring.security.oauth2.client.provider.line.tokenUri=https://api.line.me/oauth2/v2.1/token spring.security.oauth2.client.provider.line.jwkSetUri=https://api.line.me/oauth2/v2.1/verify spring.security.oauth2.client.provider.line.userInfoUri=https://api.line.me/v2/profile spring.security.oauth2.client.provider.line.userNameAttribute=userId  Spring Securtyでは、GitHub、Google、Facebook、Oktaの４つのプロバイダに関しては、各設定値の初期値が既に設定されている。なのでapploication.propatiesにはclientIdとclientSecretだけを設定すれば動作する。例えばGitHubを追加するなら、以下の設定を追加するだけで良い。\n# Settings for GitHub login spring.security.oauth2.client.registration.github.clientId={Set your client id} spring.security.oauth2.client.registration.github.clientSecret={Set your client secret}  LINEは初期値が設定されていないので全ての設定が必要になる。scopeの種類や、各エンドポイントのURI、APIの仕様などは以下を参照。\n  ウェブアプリにLINEログインを組み込む（LINEログインv2） Social API v2.0リファレンス   LINEの場合、ユーザープロファイルを取得するためのAPI(userInfoUriで指定しているエンドポイント)のレスポンスが以下のようなJSONになる。従ってuserNameAttributeには、ユーザー名に該当するuserIdを指定している。\n{ \u0026#34;userId\u0026#34;:\u0026#34;U4af4980629...\u0026#34;, \u0026#34;displayName\u0026#34;:\u0026#34;Brown\u0026#34;, \u0026#34;pictureUrl\u0026#34;:\u0026#34;https://example.com/abcdefghijklmn\u0026#34;, \u0026#34;statusMessage\u0026#34;:\u0026#34;Hello, LINE!\u0026#34; } ちなみにSpringboot v2.1.0.M2より古いバージョンは、userNameAttributeが反映されないので注意されたし。\n UserNameAttribute for custom OAuth2 provider by thiagohirata · Pull Request #10672 · spring-projects/spring-boot\n コントローラーのメソッドの引数に@AuthenticationPrincipalを指定することで、認証済みのユーザーの情報を受け取ることができるようになる。ここではシンプルにユーザー情報をレスポンスボディにそのままセットしている。\npackage com.example; import org.springframework.security.core.annotation.AuthenticationPrincipal; import org.springframework.security.oauth2.core.user.OAuth2User; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.GetMapping; @RestController public class SampleController { @GetMapping(\u0026#34;/\u0026#34;) public Object index(@AuthenticationPrincipal OAuth2User oauth2User) { return oauth2User; } } http://localhost:8080にアクセスすると、未認証の場合は、/loginにリダイレクトされる。/loginエンドポイントを実装していなければ、Spring SecurityのDefaultLoginPageGeneratingFilterが以下のログイン画面を自動生成する仕組みになっている。\nこの例ではLINEのみだが、複数のプロバイダを設定した場合はそれぞれのリンクが表示される。LINEリンクをクリックすると、http://localhost:8080/oauth2/authorization/lineに遷移する。自前のログインページを作成する場合は同じようにこのURIへ遷移するリンクなりボタンを作成すれば良い。http://localhost:8080/oauth2/authorization/lineにアクセスすると、そこから更にauthorizationUriで設定したhttps://access.line.me/oauth2/v2.1/authorizeへリダイレクトしてLINEの認証画面が表示される。認証に成功すると、http://localhost:8080/login/oauth2/code/lineへリダイレクトし、そして最初にアクセスしたhttp://localhost:8080へリダイレクトする。まとめると以下のようなページ遷移になる。\nhttp://localhost:8080 ↓ リダイレクト http://localhost:8080/login ↓ リンクをクリック http://localhost:8080/oauth2/authorization/line ↓ リダイレクト https://access.line.me/oauth2/v2.1/authorize ↓ 認証成功 http://localhost:8080/login/oauth2/code/line ↓ リダイレクト http://localhost:8080  なお、認証成功時のリダイレクト先のURLについては、LINE Developer画面上でホワイトリストに設定しておく必要がある。LINE以外の他のプロバイダでも同様。\n別の実装方法 LINE Engieeringブログで、spring-boot-starter-securityとspring-security-oauthを使った実現方法が紹介されていたが、この方法だとOAuth2プロバイダが１つしか指定できなかったので採用しなかった。実際はLINEだけでなくGoogleやFacebookと併用したいケースが多いのではないだろうか。\n Spring Security + 設定ファイルで始める LINE との ID Federation : LINE Engineering Blog\n "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/tokyo-metro-vim/",
        "title": "東京メトロ配色のVimカラースキームを作った",
        "section": "blog",
        "date" : "2018.09.24",
        "body": " VimConf2017でcocoponさんがicebergというカラースキーマを作った時の話をしているのを聞いて自分もオリジナルのカラースキーマを作ってみたいと思った。東京に住んでるし東京をテーマとしたカラーススキームを作れないかとちょっと考えたものの、色彩センスに自信がなかったので、東京メトロのテーマカラーを使ってみることにした。\nソースコード koirand/tokyo-metro.vim: Vim color scheme using theme color of Tokyo Metro lines.\n作成過程 まずはPhotoshopで各路線のテーマカラーを並べた。\nダークモード派なので黒背景。思ったより見やすい印象を得た。さすが偉い人が考えた配色である。ただ千代田線と南北線の色が似ていて使い分けが難しい。カラースキームの自作方法についてWebで調べて見たところ、設定項目数が多くなかなか大変そうだったので、iceberg.vim をForkしてカスタマイズすることにした。README に記載されているが、カラースキーマを半自動生成する仕組みが提供されているのでこれを使用した。具体的な手順としては以下の通り。\n cocopon/pgmnt プラグインをVimにインストール。 src/template.vim にあるテンプレートを変更。 autoload/iceberg/palette/dark.vim をコピーして、autoload/tokyometro/palette/dark.vim を作成して、配色を変更。:source % してVimに読み込む。 src/iceberg.vim をコピーして src/tokyo-metro.vim を作成して、色と対象オブジェクトのマッピングを少し調整。cd %:hしてカレントディレクトリを変更してから:source %すると、color/tokyo-metro.vim が生成される。  できたのがこちら。 tokyo-metro - Vim Colors\n濃紺の背景は東京の夜景っぽくて違和感なかったのでオリジナルのままにした。このサンプルでは表示されてないけど、言語によっては演算子が副都心線の茶色になるはず。それから丸ノ内線については、やは赤はエラー感が強く出てしまい違和感が拭えなかったので、丸の内線ユーザーには申し訳ないが素直にエラー系の色を当てることにした。\n作ってみた感想 オリジナルカラースキームができてうれしい。cocopon/pgmnt プラグインが良く作られている。色をHSLで指定できるので、微妙な色の調整がやりやすそうに感じた。今回テーマカラーありきだったので、あまり配色には悩まなかったが、次回作るときは配色に拘ってみたい。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/post-test/",
        "title": "Post Test",
        "section": "blog",
        "date" : "2018.09.23",
        "body": " 見出し1（h1） 見出し1（h1） 見出し2（h2) 見出し2（h2） 見出し3 見出し4 見出し5 見出し6 ここは段落です。♪もーもたろさん もーもたーろさん おっこしーにつっけたーちーびまーるこー\nここは段落です。\n↑半角スペース2個で強制改行しています。\n♪もーもたろさん もーもたーろさん おっこしーにつっけたーちーんあーなごー\n 強い強調（strong）です。 これも強い強調です。 \u0026lt;strong\u0026gt;strongタグです。\u0026lt;/strong\u0026gt; 強調（em）です。 これも強調です。 斜体の\u0026lt;em\u0026gt;タグになります。 強調斜体です。 強調斜体です。 \u0026lt;strong\u0026gt;＋\u0026lt;em\u0026gt;タグになります。   引用（Blockquote）です\n 引用のネストです\n 上に一行空けないとネストのままです\n 引用（Blockquote）の中にはMarkdown要素を入れられます\n 見出し  数字リスト 数字リスト   エスケープ文字 *アスタリスクをバックスラッシュでエスケープ*\n## 見出しハッシュ文字をエスケープ\nHTMLタグをバックスラッシュでエスケープ→（\u0026lt;p\u0026gt;）\nHTMLをバッククォートでインラインコード→（\u0026lt;p\u0026gt;）\n水平線（\u0026lt;hr\u0026gt;）各種 アスタリスク3個半角スペース空けて\nアスタリスク3個以上\nハイフン半角スペース空けて\n続けてハイフン3個以上\nリスト  ハイフン箇条書きリスト プラス箇条書きリスト 米印箇条書きリスト  二階層め・箇条書きリスト  三階層め・箇条書きリスト 四階層め・箇条書きリスト   箇条書きリスト   番号付きリスト  二階層め・番号付きリスト1 二階層め・番号付きリスト2  番号付きリスト2  二階層め・番号付きリスト1  三階層め・番号付きリスト1 三階層め・番号付きリスト2 四階層め・番号付きリスト1  二階層め・番号付きリスト2  番号付きリスト3   定義リストタイトル 定義リスト要素1 定義リスト要素2 定義リスト要素3  コードブロック バッククォート or 半角チルダ3個でくくります。 ###ここにはMarkdown書式は効きません /* コメント */ testtest // コメント  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt; \u0026lt;title\u0026gt;ニョロニョロ囲みhtml\u0026lt;/title\u0026gt; /* コメント */  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt; \u0026lt;title\u0026gt;バッククォート囲みhtml\u0026lt;/title\u0026gt;  body { display: none; } /* バッククォート囲みcss */ // コメント  // 先頭に半角スペース4つでcode囲い \u0026lt;?php if (is_tag()){ $posts = query_posts($query_string . '\u0026amp;showposts=20'); } ?\u0026gt;  バッククォート1個ずつで囲むとインラインのコード（\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;）です。body { visibility: hidden; }\nリンク markdownでテキストリンク WIRED.jp\n\u0026lt;カッコ\u0026gt;でくくってリンク http://wired.jp/\n定義参照リンクです。SNSには Twitter や Facebook や Google+ などがあります。\n画像 table    Left align Right align Center align     This This This   column column column   will will will   be be be   left right center   aligned aligned aligned    （Kobitoのヘルプmdから拝借しました）\nGFM リンク URLそのまま貼り付け http://wired.jp/\n段落中の改行 ここは段落です。 ↑returnで改行しています。 ♪もーもたろさん もーもたーろさん おっこしーにつっけたーちー○○ー○○ー\nコードブロック バッククォートの開始囲みに続けて拡張子でシンタックスハイライト\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;バッククォート囲みに拡張子付きhtml\u0026lt;/title\u0026gt; /* コメント */body { display: none; } /* コメント */\u0026lt;?php if (is_tag()){ $posts = query_posts($query_string . \u0026#39;\u0026amp;showposts=20\u0026#39;); } ?\u0026gt;  取り消し線 取り消し線（GFM記法）\nsタグです。\n単語中のアンダースコアの無効 GitHub_Flavored_Markdown_test_test\ntasklist task1 task2 completed task  from Markdown記法 表示確認用サンプル - Qiita\n"
    }
]
