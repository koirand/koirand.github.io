[
    {
        "ref": "https://koirand.github.io/blog/2019/slack-balance/",
        "title": "口座残高をSlackに通知する",
        "section": "blog",
        "date" : "2019.04.30",
        "body": " GWだし何か作ろうということで、銀行の口座残高をスクレイピングしてSlackに通知というのをやってみた。\nソースコード koirand/slack-balance: Get bank balance and send to slack\n自分はMUFGをメインバンクとして使っているので、MUFGダイレクトのサイトにログインして口座残高を取得するように作ってみたものの、どうせなら他の口座の残高も見たいなあと作ってから気づいた。そこでMoneyForwardの口座ページにアクセスして、MoneyForwardと連携している口座残高の取得もできるようにした。ただ、MoneyForwardの残高はリアルタイムではないので、MUFGの処理は残しておくことにした。\nchromedp 今どきSelenium使うのもいけてないので、chromedpを使うことにした。chromedpはChrome DevTools Protocolを使ってChromeを自動操作するツール。Go言語でサクッと書ける。\nchromedp/chromedp: A faster, simpler way to drive browsers supporting the Chrome DevTools Protocol.\nExampleを見るとだいたいやり方がわかるかと。\nchromedp/examples: chromedp code examples.\nExampleのevalを見ると、\nchromedp.Evaluate(`Object.keys(window);`, \u0026amp;res)  のように、どうやら任意のJSの戻り値を取得することもできる模様。 また、Exampleのheadersを実行するとリクエストヘッダが見れる。Macで実行したらUserAgentは以下となっていた。\n\u0026quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_4) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/74.0.3729.108 Safari/537.36\u0026quot;  HeadlessChromeでアクセスしていることがサイト運営者には分かるようなので一応注意されたし。\nSlack Incoming Webhook Slackへの通知はIncoming Webhooksを使って実装した。実装といってもWebサイト上でWebhook URLを発行して、そこにPOSTすれば良いだけなので拍子抜けするほど簡単だった。\nSlack API | Slack\nこんな感じで通知できてる。良い。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2019/nixie-timer/",
        "title": "ニキシー管風のカウントダウンタイマーを作った",
        "section": "blog",
        "date" : "2019.04.06",
        "body": " 「今年はunstatedがくる」と同僚が言っていたのでunstatedを使ってなにか作ってみようと思った。unstatedはReactのContextを使ってStateを簡単に管理できるモジュール。ソースコードは200行に満たないにも関わらずとても強力。\n jamiebuilds/unstated: State so simple, it goes without saying\n 作ったもの koirand/nixie-timer: Nixie tube style count down timer.\nデモは こちら 。時間を設定して[Start]ボタンを押すとカウントダウンが始まる。カウントダウン中は時計以外が隠れるので、デザインスプリントやワークショップなどで、スクリーンとかモニタとかに映すと格好がよろしいかと。画像の素材は Photoshop ニキシー管風味カウンター素材 - trismegistuslabo トリメギ から拝借させてもらった。\nunstated使ってみた感想 今いる会社はフロントエンドのエンジニアがそんなにいないのでReduxを社内で使っていくのは正直厳しいが、unstatedなら覚えることが少なくて大丈夫そうだと感じた。componentDidMountなどでStateを更新したい場合にHOCをかまさないといけないのが若干アレだけど慣れれば大したことない。\ngh-pages 今回 gh-pages - npm を使ってデモページをデプロイしてみた。このモジュールもとてもお手軽で良かった。\n\u0026quot;scripts\u0026quot;: { \u0026quot;predeploy\u0026quot;: \u0026quot;yarn build\u0026quot;, \u0026quot;deploy\u0026quot;: \u0026quot;gh-pages -d build -m \\\u0026quot;[ci skip]\\\u0026quot;\u0026quot; }  package.jsonにこのようにscriptsを書いておけば、yarn deployするとGitHub Pagesにデプロイできる。ちなみにCIをスキップするために、-mオプションでコミットメッセージに[ci skip]を入れるようにしている。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2019/git-zoo/",
        "title": "Gitのログを動物園にする",
        "section": "blog",
        "date" : "2019.04.06",
        "body": "Gitのログに絵文字のプレフィックスを入れている人をたまに見かける。バグだったら :bug: とか、テストだったら :white_check_mark: とか。見やすくていいんだけど、なんか仕事のルールって感じがして、もっと自由で無意味で楽しく開発したいと思った。例えば動物の絵文字を追加するとか。\n自動で絵文字を追加できたりしないのかなと思って調べたら、Git hookというものがあることを知った。\n Git - Git フック\n prepare-commit-msgでゴニョゴニョすることで、コミットメッセージを書き換えられるらしいので、ランダムに動物の絵文字を追加するツールを作ってみた。\n koirand/git-zoo: Add animals emoji to git commit message.  使い方はREADMEにある通り、適用したいGitリポジトリの.git/hooks/prepare-commit-msgにシンボリックリンクを作成すると、コミット時にコミットメッセージの行頭にランダムな動物の絵文字が挿入されるようになる。\nこんな風に楽しい感じになる。会社でやるとたぶんウザがられるのでオススメはしない。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2019/react-eslint/",
        "title": "create-react-appで作ったアプリをESLintする",
        "section": "blog",
        "date" : "2019.03.11",
        "body": " Sider というGitHubのプルリクエストを自動でレビューしてくれるサービスがあり、これをちょっと使ってみようと思った。 以前 React開発環境構築(create-react-app利用) に書いたとおり、ESLintの設定がダルいので普段はStandard Styleのモジュールを入れてLintの設定は簡単に済ましているが、このSiderがStandard Styleには対応してなくてJSHintかESLintにしか対応していないようなので、今回ESLintでLintしてみた。\nモジュールのインストール react-create-appにはReactをESLintするために必要なモジュールは同梱されている。なのでStandard Style用のプラグインだけ追加で入れる。\nyarn add -D \\ eslint-config-standard \\ eslint-plugin-node \\ eslint-plugin-standard \\ peslint-plugin-promis \\ prettier-standard  .eslintrc.json こいつが面倒\u0026hellip;かと思いきや下記の設定だけで良い模様。\n{ \u0026quot;extends\u0026quot;: [\u0026quot;react-app\u0026quot;, \u0026quot;standard\u0026quot;] }  これで yarn run eslint src/ などやればLintしてくれる。\nVimの設定(ALE) ALEはLintのモジュールを自動検知してくれるので、ESLintになっても設定は変更しなくても問題なかった。\nlet g:ale_fixers = {'javascript': ['prettier_standard']} let g:ale_fix_on_save = 1  Atom reactプラグインとlinter-eslintを入れればOK。 linter-eslintの設定をいじれば自動修正もしてくれる。\nVSCode eslintプラグインを入れればOK。 設定をいじれば自動修正もしてくれる。\nまとめ 思ったより設定項目少なくて楽だった。最初からこうすれば良かった感がある。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2019/macos-setting/",
        "title": "Mac初期設定メモ",
        "section": "blog",
        "date" : "2019.03.03",
        "body": " MacbookにMojaveをクリーンインストールしたのでその時の初期設定の記録。\nアプリインストール Apple Storeから  BetterSnapTool Slack LINE BitWarden Skitch  Webからダウンロード  Google Chrome Google 日本語入力 Karabiner iTerm2 Atom VS Code Docker Clipy AppCleaner Zoom Spotify Adobe Creative Cloud PokerStars Amazon WorkSpaces LICEcap VLC  Homebrewから brew install \\ tmux \\ git \\ hub \\ vim \\ fish \\ htop \\ screenfetch \\ go \\ dep \\ nodebrew \\ pyenv \\ hugo \\ gibo \\ wget \\ tree \\ tidy-html5  terminfoに設定を追加しておく(tmuxで斜体文字を使うため) Italic fonts in iTerm2, tmux, and vim - Alex Pearce\n/tmp/xterm-256color-italic.terminfo を作成\n# A xterm-256color based TERMINFO that adds the escape sequences for italic. xterm-256color-italic|xterm with 256 colors and italic, sitm=\\E[3m, ritm=\\E[23m, use=xterm-256color,  設定を読み込む\ntic /tmp/xterm-256color-italic.terminfo  MacOS設定  バッテリーアイコンを%表示に変更 システム環境設定  一般  書類を閉じるときに変更内容を保持するかどうかを確認 にチェック  Dock  Dockを左に表示  Mission Control  「最新の使用状況に基づいて操作スペースを自動的に並び替える」をオフ  キーボード  キーリピートとリピート入力認識までの時間をMAXに ショートカット -\u0026gt; 入力ソース を無効に  iCloud  Macを探す以外のチェックを解除  インターネットアカウント  Googleアカウント登録  アクセシビリティ  マウスとトラックパッド -\u0026gt; トラックパッドオプション -\u0026gt; 3本指のドラッグを有効   Finder  環境設定  サイドバー  ホームディレクトリとルートディレクトリを追加 タグは使わないので解除  詳細  拡張子を表示   メニューバーの表示  パスバーを表示   Karabiner  Simple Modification でCaps LockをCtrlに変更 Complex Modification の Add rule の import more \u0026hellip; の For Japanese の設定をインポート  BetterSnapTool  Mac起動時に自動起動 Keyboard Shortcuts   iTerm2  Plofiles  Colors -\u0026gt; テーマ をインポート Text -\u0026gt; Blinking cursorにチェック、フォントを14pt Monacoに変更 Teminal  Silence bellにチェック Report Terminal Type を xterm-256color-italic に変更     dotfiles Google DriveからSSH鍵をダウンロードして.sshディレクトにいれておく\nmkdir ~/Projects git clone git@github.com:koirand/dotfiles.git ~/Projects/dotfiles ln -s ~/Projects/dotfiles/.gitconfig ~/.gitconfig ln -s ~/Projects/dotfiles/.vimrc ~/.vimrc ln -s ~/Projects/dotfiles/.vim ~/.vim ln -s ~/Projects/dotfiles/.tmux.conf ~/.tmux.conf ln -s ~/Projects/dotfiles/.textlintrc ~/.textlintrc  cheetsheet git clone git@gist.github.com:07d9a3195a38d5a14e636bdbec0e0862.git ~/Projects/cheetsheet  fish  /etc/shells に/usr/local/bin/fishを追記 chsh -s /usr/local/bin/fish fisher をインストール pure をインストール ~/.config/fish/config.fish を変更 (Gist) コマンドの色が見辛いので ~/.config/fish/fish_variables を変更  SETUVAR fish_color_command:normal  設定後のスクリーンショット "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2019/bitbucket-to-github/",
        "title": "ブログのリポジトリをGitHubに移行した",
        "section": "blog",
        "date" : "2019.03.02",
        "body": " 以前、ブログ(HUGO)のビルドとデプロイをCircleCIで自動化した に書いた通り、ブログのリポジトリはBitbucketで管理して、ブログをビルドした結果生成されるhtmlファイルはGitHubにデプロイしていたが、先日GitHubのプライベートリポジトリが無料化されたのでGitHubだけで完結するようにリポジトリを移行してみた。\nBefore After CircleCIでのSSHキーの登録 特に難しいところはなかったが、SSHキーの登録だけ少しハマったのでメモ。 CircleCIのプロジェクト設定にあるPERMISSIONS -\u0026gt; Checkout SSH keys からSSHキーを登録する際、デプロイキーを追加する方法と、ユーザーキーを追加する方法の２種類がある。 最初にデプロイキーを選択したがうまく動かなかった。デプロイキーだとブログ用のリポジトリ(図の左上のリポジトリ)のRead権限しか付与されないので、GitHub Pages用のリポジトリ(図の右上のリポジトリ)に対してデプロイできる権限を付与できなかった。 一方ユーザーキーだと、全てのリポジトリにRead/Write権限を付与でき、これだとうまくデプロイできた。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/create-react-app/",
        "title": "React開発環境構築(create-react-app利用)",
        "section": "blog",
        "date" : "2018.12.10",
        "body": " Reactアプリの開発環境を一から構築するのは中々辛いものがある。たくさんモジュールを入れないといけないし、それらのモジュールの依存関係にも気を配らないといけない。ビルドやlintの設定を書くのも面倒。しかし今はcreate-react-appという便利なコマンドがあるようなので使ってみた。\n公式ドキュメント Create React App · Set up a modern web app by running one command.\nアプリケーションの作成 $ yarn global add create-react-app $ create-react-app my-app yarn create v1.12.3 [1/4] 🔍 Resolving packages... [2/4] 🚚 Fetching packages... [3/4] 🔗 Linking dependencies... [4/4] 📃 Building fresh packages... success Installed \u0026quot;create-react-app@2.1.1\u0026quot; with binaries: - create-react-app [################################################################] 64/64 Creating a new React app in /Users/kazuki/Projects/my-app. Installing packages. This might take a couple of minutes. Installing react, react-dom, and react-scripts... yarn add v1.12.3 [1/4] 🔍 Resolving packages... [2/4] 🚚 Fetching packages... [3/4] 🔗 Linking dependencies... [4/4] 📃 Building fresh packages... success Saved lockfile. success Saved 6 new dependencies. info Direct dependencies ├─ react-dom@16.6.3 ├─ react-scripts@2.1.1 └─ react@16.6.3 info All dependencies ├─ babel-preset-react-app@6.1.0 ├─ react-dev-utils@6.1.1 ├─ react-dom@16.6.3 ├─ react-error-overlay@5.1.0 ├─ react-scripts@2.1.1 └─ react@16.6.3 ✨ Done in 9.55s. Initialized a git repository. Success! Created my-app at /Users/kazuki/Projects/my-app Inside that directory, you can run several commands: yarn start Starts the development server. yarn build Bundles the app into static files for production. yarn test Starts the test runner. yarn eject Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!   yarn create | Yarn\n ちなみに、TypeScriptを使う場合は、\n$ create-react-app my-app --typescript  と--typescriptをつければ良いらしい。\nファイル構成 my-app ├── .git ├── .gitignore ├── README.md ├── node_modules ├── package.json ├── public | ├── favicon.ico | ├── index.html | └── manifest.json ├── src | ├── App.css | ├── App.js | ├── App.test.js | ├── index.css | ├── index.js | ├── logo.svg | └── serviceWorker.js └── yarn.lock  READMEやserviceWorker、manifest.jsonも生成してくれて、gitの初期化までしてくれる。至れり尽くせり。以下利用上の注意点。 - public/index.htmlとsrc/index.jsはリネーム、削除してはいけない - ビルド時の処理対象はsrcフォルダ配下のみ - ビルド後の静的ファイルが参照できるのはpublicフォルダ配下のみ\npackage.json Babelやwebpackのややこしいところがreact-scriptsで抽象化されている。\n{ \u0026quot;name\u0026quot;: \u0026quot;my-app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.1.0\u0026quot;, \u0026quot;private\u0026quot;: true, \u0026quot;dependencies\u0026quot;: { \u0026quot;react\u0026quot;: \u0026quot;^16.6.3\u0026quot;, \u0026quot;react-dom\u0026quot;: \u0026quot;^16.6.3\u0026quot;, \u0026quot;react-scripts\u0026quot;: \u0026quot;2.1.1\u0026quot; }, \u0026quot;scripts\u0026quot;: { \u0026quot;start\u0026quot;: \u0026quot;react-scripts start\u0026quot;, \u0026quot;build\u0026quot;: \u0026quot;react-scripts build\u0026quot;, \u0026quot;test\u0026quot;: \u0026quot;react-scripts test\u0026quot;, \u0026quot;eject\u0026quot;: \u0026quot;react-scripts eject\u0026quot; }, \u0026quot;eslintConfig\u0026quot;: { \u0026quot;extends\u0026quot;: \u0026quot;react-app\u0026quot; }, \u0026quot;browserslist\u0026quot;: [ \u0026quot;\u0026gt;0.2%\u0026quot;, \u0026quot;not dead\u0026quot;, \u0026quot;not ie \u0026lt;= 11\u0026quot;, \u0026quot;not op_mini all\u0026quot; ] }  create-react-appに含まれるもの $ npm ls --depth=1 my-app@0.1.0 ├── node-pre-gyp@0.10.3 extraneous ├─┬ react@16.6.3 │ ├── loose-envify@1.4.0 │ ├── object-assign@4.1.1 │ ├── prop-types@15.6.2 │ └── scheduler@0.11.3 ├─┬ react-dom@16.6.3 │ ├── loose-envify@1.4.0 deduped │ ├── object-assign@4.1.1 deduped │ ├── prop-types@15.6.2 deduped │ └── scheduler@0.11.3 deduped └─┬ react-scripts@2.1.1 ├── @babel/core@7.1.0 ├── @svgr/webpack@2.4.1 ├── babel-core@7.0.0-bridge.0 ├── babel-eslint@9.0.0 ├── babel-jest@23.6.0 ├── babel-loader@8.0.4 ├── babel-plugin-named-asset-import@0.2.3 ├── babel-preset-react-app@6.1.0 ├── bfj@6.1.1 ├── case-sensitive-paths-webpack-plugin@2.1.2 ├── chalk@2.4.1 ├── css-loader@1.0.0 ├── dotenv@6.0.0 ├── dotenv-expand@4.2.0 ├── eslint@5.6.0 ├── eslint-config-react-app@3.0.5 ├── eslint-loader@2.1.1 ├── eslint-plugin-flowtype@2.50.1 ├── eslint-plugin-import@2.14.0 ├── eslint-plugin-jsx-a11y@6.1.2 ├── eslint-plugin-react@7.11.1 ├── file-loader@2.0.0 ├── fork-ts-checker-webpack-plugin-alt@0.4.14 ├── fs-extra@7.0.0 ├── fsevents@1.2.4 ├── html-webpack-plugin@4.0.0-alpha.2 ├── identity-obj-proxy@3.0.0 ├── jest@23.6.0 ├── jest-pnp-resolver@1.0.1 ├── jest-resolve@23.6.0 ├── mini-css-extract-plugin@0.4.3 ├── optimize-css-assets-webpack-plugin@5.0.1 ├── pnp-webpack-plugin@1.1.0 ├── postcss-flexbugs-fixes@4.1.0 ├── postcss-loader@3.0.0 ├── postcss-preset-env@6.0.6 ├── postcss-safe-parser@4.0.1 ├── react-app-polyfill@0.1.3 ├── react-dev-utils@6.1.1 ├── resolve@1.8.1 ├── sass-loader@7.1.0 ├── style-loader@0.23.0 ├── terser-webpack-plugin@1.1.0 ├── url-loader@1.1.1 ├── webpack@4.19.1 ├── webpack-dev-server@3.1.9 ├── webpack-manifest-plugin@2.0.4 └── workbox-webpack-plugin@3.6.3  だいたい必要なやつは入っている。PrettireやCSS in JSは標準では入っていないようなので、使いたい場合は自分で入れる必要がある。\nLint、Prettire .eslintrcや.prettierrcを書くのはとてもダルいので、Standard Style専用のモジュールを入れてしまう。\nyarn add -D standard prettier-standard    JavaScript Standard Style sheerun/prettier-standard: (✿◠‿◠) Prettier and standard brought together!   Macで開発する場合、標準で入っているtidyのバージョンが古く、HTML5に対応していないので、tidy-html5を入れておくと良い。\n$ brew install tidy-html5  Vimの設定 以下の設定にすると、保存時に自動的に修正されるようになる。楽チン。\nlet g:ale_fixers = {'javascript': ['prettier_standard']} let g:ale_fix_on_save = 1  Atom 以下２つのプラグインを入れればOK\n linter-js-standard standard-formatter  VSCode StandardJS プラグインを入れればOK\nまとめ 思ったより使いやすくて気に入った。webpack.config.jsを書かなくて済むのは大変良い。facebookのオフィシャルツールなので安心感がある。同じようなコンセプトのモジュールにParcelというものもあるので、React以外の場合は使ってみると良いかもしれない。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/package-manager/",
        "title": "パッケージマネージャーのチートシート",
        "section": "blog",
        "date" : "2018.11.30",
        "body": "前回の設定ファイルの書式と同様、パッケージマネージャーのコマンドもチートシートを作ってみた。コマンドのhelpで確認はできるが、パッケージマネージャーによってコマンドの意味が微妙に違っていたりするのでチートシートで目的からコマンドの逆引きしたほうが安心できる。自分用なので自分が使うものだけとはいえapt(Debian)、yum(Red Hat)、Homebrew(Mac OS)、npm(JavaScript)、yarn(JavaScript)、pip(Python)、dep(Golang)と結構種類が多い。パッケージマネージャーとはやや異なるがfisherman(fish)、Helm(Kubernetes)もついでなので一緒に記載しておいた。\n   Use Case apt(旧) apt(新) yum Homebrew npm yarn pip dep fisherman Helm     パッケージ追加 apt-get install apt-install yum install brew install npm install yarn add pip install dep ensure fisher install helm install   パッケージ削除 apt-get remove apt remove yum remove brew uninstall npm uninstall yarn remove pip uninstall dep remove fisher rm helm delete   リポジトリ更新 apt-get update apt update - brew update - - - - - helm update   パッケージ更新 apt-get upgrade apt upgrade yum update brew upgrade npm update yarn upgrade pip install -U - fisher update helm upgrade   パッケージ検索 apt-cache search apt search yum search brew search npm search - pip search - - helm search   パッケージ詳細 apt-cache show apt show yum info brew info npm view yarn info pip show - - helm inspect   追加したパッケージの確認 dpkg -l dpkg -l yum list installed brew list npm ls yarn list pip list dep status fisher ls helm list   ゴミパッケージの掃除 apt-get autoremove apt autoremove yum autoremove - npm prune yarn install - dep prune - -    Homebrewにautoremoveが無くて辛いことが良くあって、何か方法はないかと調べたらスクリプトをつくっている人がいた(しかもfish)。ありがたく拝借した。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/ini-json-yaml-toml/",
        "title": "INI,JSON,YAML,TOMLのチートシート",
        "section": "blog",
        "date" : "2018.11.19",
        "body": " 設定ファイルの書式についてググることが多かったので自分用にチートシートを作成してみた。設定ファイルの規格で思いつくのは、INI、XML、JSON、YAML、TOMLの５種類。他にもあるだろうが私には接点がない。INIは物心ついたころには既にあった気がする。Windows 95のアプリケーションの設定ファイルがINIだった。それからphp.iniの印象が強い。今でも.gitconfigなどで触れる機会がある。XMLはJAVAのweb.xmlが最初の出会いだった。当時からなんでこんな扱いづらいフォーマットで書くのか理解できなかった。XMLが嫌でJAVAやApacheを使いたくないところがある。今でも古めのAPIはXMLだったりするし、SAMLなんかもXMLだ。JSONとの出会いは正直覚えていないが、何かしらのREST-APIだと思われる。Node.jsのpackage.jsonで良く触れる。YAMLはRubyを使ってこなかったのでこれまで接点が無かったが、最近Kubernetesを使い始めて良く触るようになった。TOMLはGolangを使った時に初めて触れた。Go言語界隈ではTOMLが良く使われている。HUGOの設定もTOMLだ。\n以上唐突な自分語り。何が言いたいのかというと、TPOに合わせて色々な規格を読み書きしないといけなくてややこしいと言うことだ。\nついでなので各規格の登場年月を調べた。\n   規格 初版     INI -   XML 1998年   YAML 2001年5月   JSON 2006年7月   TOML 2013年2月    意外とYAMLが古い。INIはWikipediaによると規格化・標準化されていないらしい。今初めて知った。自然発生的に生まれたと言うことだろうか。不思議な書式だ。そういう意味ではTOMLはINIを規格化したものと言えるのだろうか。ちなみに各フォーマットをGoogleトレンドだとこんな感じ。\nチートシート というわけでチートシート。(XMLは書かない)\nINI ; コメント key1=value1 [section] key2=value2 key3=1.1  INIに配列やネストを記述する方法はない。\nJSON { \u0026quot;key1\u0026quot;: \u0026quot;value1\u0026quot;, \u0026quot;key2\u0026quot;: { \u0026quot;key3\u0026quot;: null, \u0026quot;key4\u0026quot;: [ 1.1, 2.2 ] }, \u0026quot;key5\u0026quot;: [ { \u0026quot;key6\u0026quot;: 3, \u0026quot;key7\u0026quot;: true }, { \u0026quot;key6\u0026quot;: 4, \u0026quot;key7\u0026quot;: false } ] }  JSONにコメントはない。\nYAML # コメント key1: value1 # コメント key2: key3: null key4: - 1.1 - 2.2 key5: - key6: 3 key7: true - key6: 4 key7: false  TOML # コメント key1: \u0026quot;value1\u0026quot; # コメント [key2] key3: null key4: [1.1, 2.2] [[key5]] key6: 3 key7: true [[key5]] key6: 4 key7: false key8: 2018-11-19 key9: 2018-11-19T15:30:00+09:00 #日本時間15:30  "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/textlint/",
        "title": "ブログの記事をtextlintで校正してみた",
        "section": "blog",
        "date" : "2018.11.11",
        "body": " このブログを書いていて、記事を公開してしまってから間抜けな誤字脱字に気づくことが度々あった。慌てて修正してPushして確認すると、また別のミスを見つけてしまって、何度も修正する羽目になる。個人ブログなので神経質になる必要はないがミスを見つけてしまうと何となく気になって修正してしまう。流石に虚しいので文章校正の仕組みを入れることにした。今はVimというテキストエディタで記事を書いているので、Vim上で文書校正をしてみた。\ntextlintのインストール 文章校正ツールである textlint インストール。ルールは種類が多すぎて正直どれを入れれば良いのか迷う。とりあえず無難そうな 技術文書向けのtextlintルールプリセットと、Webエンジニア向けの辞書 をインストールしてみた。\n$npm install -g textlint $npm install -g textlint-rule-preset-ja-technical-writing textlint-rule-spellcheck-tech-word  textlintの設定 ホームディレクトリに.textlintrcを作成する。デフォルトだと一文の長さが100文字を越えると警告が表示されるが、100文字だとURLなどを記載するとすぐに超えてしまうので200文字で上書きした。\n{ \u0026quot;rules\u0026quot;: { \u0026quot;preset-ja-technical-writing\u0026quot;: { \u0026quot;sentence-length\u0026quot;: { \u0026quot;max\u0026quot;: 200 } }, \u0026quot;spellcheck-tech-word\u0026quot;: true } }  Vimプラグインの導入 vimrcの設定例は以下。Lintエンジンの w0rp/ale と、ステータスラインをカスタマイズする itchyny/lightline.vimを使っている。\n\u0026quot; ale let g:ale_linters = { \\ 'markdown': ['textlint'] \\} \u0026quot; lightline let g:lightline = { \\ 'active': { \\ 'left': [ \\ ['mode', 'paste'], \\ ['readonly', 'filename', 'modified', 'ale'], \\ ] \\ }, \\ 'component_function': { \\ 'ale': 'ALEGetStatusLine' \\ } \\ }  結果 こんな感じで警告してくれるようになった。行番号の箇所に警告マークが表示され、そこにカーソルを合わせると警告の内容が一番下に表示される。また警告の総数がステータスラインに表示されている。便利。 "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/pulp-search2/",
        "title": "HUGOテーマ(pulp)の全文検索をあいまい検索に変更した",
        "section": "blog",
        "date" : "2018.10.31",
        "body": " 前回の記事「HUGOテーマ(pulp)に全文検索機能を付けた」でブログのテーマに全文検索機能を追加したが、HUGOのテーマとして配布し辛いという課題があった。lunr.js単体だけだとスペースで単語を区切らない言語での検索ができない。日本語も然り。トークナイズ用のプラグインを使えば正しく分かち書きされて検索できるようになるが、基本的にプラグインは特定の言語に特化したものなので、不特定な言語に対応できない。\nこの問題の解決方法としては以下２つが考えられる。\n N-gramを使う インデックスを使わない普通の検索にする  まずはN-gram方式を試してみた。lune.jsのトークナイズプラグインを探しても見つからなかったが、 Pull Request #63 olivernn/lunr.js　に紹介されているようにN-gramでの分割処理を実装してtokenizerに登録すればできる。\nvar myNgramTokenizer = function () { lunr.tokenizer = function (obj) { // ngram implementation } } idx.use(myNgramTokenizer)  検索クエリも同様にN-gramで分割処理をしてあげれば検索ができる。ただ単純なN-gramだけでは検索精度がいまひとつだった。第5回 N-gramのしくみ：検索エンジンを作る｜gihyo.jp … 技術評論社 にも記載されている通り、分割した文字列片がそれぞれバラバラの箇所でヒットしてしまう問題がある。検索精度を高めるためには、ヒットした文字列片の出現位置を見てあげる必要があるようだ。\nN-gramの実装はなかなか大変そうだったので、インデックスはあきらめてFuse.jsというあいまい検索のライブラリを使うことにした。Fuse.jsのデフォルトのオプションだと本文の先頭32文字しかヒットしないが、Hugo JS Searching with Fuse.js で紹介されている通り、tokenizeオプションを有効にすると全文検索可能になる。色々オプションを試して以下に落ち着いた。\nvar options = { shouldSort: true, tokenize: true, matchAllTokens: true, threshold: 0.3, minMatchCharLength: 5, keys: ['title', 'body'] }  検索精度は上々、不特定な言語でも問題ないはず。しかもあいまい検索なので若干スペルを間違えても検索ができる。ただしインデックスを使っていないのでパフォーマンスは悪い。前回と同じく Skycoin社のブログデータを使って試してみたら約150件の記事でも結構検索がカクついた。一旦はこれで運用するが、N-gramをもう少し頑張ったほうが良さそうだ。全文検索の道のりは思ったより険しい。\n2019-04-06 追記 やっぱりFuse.jsでのあいまい検索はパフォーマンス面が心配だったので、lunr.jsに戻してN-gramを実装する方式に変更した。jsファイルはこちら。\n pulp/search.js at master · koirand/pulp  インデックスを作成するときに使うトークナイザー(bigramTokeniser)を作成し、builder.tokenizer = bigramTokeniser の箇所でそれを利用している。\n検索時のクエリも同様に、N-gramでの分割関数(queryNgramSeparator)を作成し、検索時にlunrResult = lunrIndex.search(queryNgramSeparator(query))として使っている。これでN-gramが実現できた。全文検索の動作は このブログ で確認できる。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/pulp-search/",
        "title": "HUGOテーマ(pulp)に全文検索機能を付けた",
        "section": "blog",
        "date" : "2018.10.08",
        "body": " 先日作ったpulpというHUGOのテーマに全文検索機能を付けてみた。タグやカテゴリで分類するのが個人的に面倒臭いと思ってしまうので、何もしなくても本文が検索できればいいなと思っていた。しっかり作るならElasticSearchやAlgoliaを使うんだろうけど、そうするとThemeとして配布しづらくなるし、個人用途としてはそこまでの機能はいらないのでフロントエンドだけで完結する方法を模索した。\nデモ 記事をJSONで取得できるようにする まずは、HugoでJSONを出力 | Celeumu を参考にしつつブログの記事をJSONで取得できるようにした。config.tomlに以下を追記すると、拡張子が.jsonのテンプレートをHUGOがテンプレートとして見てくれるようになった。\n[outputs] section = [\u0026quot;JSON\u0026quot;, \u0026quot;HTML\u0026quot;]  その上でlayouts/_default/list.json を作成すると、http://hostname/section/index.json といったURLでいとも簡単にセクションのデータをJSONで引っこ抜くことができるようになる。このブログの場合だと、https://koirand.github.io/blog/index.json からデータが取得できる。\n[{{ range $index, $page := .Pages }}{{ if ne $index 0 }},{{ end }} { \u0026quot;ref\u0026quot;: \u0026quot;{{ $page.Permalink }}\u0026quot;, \u0026quot;title\u0026quot;: {{ $page.Title | jsonify }}, \u0026quot;section\u0026quot;: \u0026quot;{{ $page.Section }}\u0026quot;, \u0026quot;date\u0026quot; : {{ $page.Date.Format \u0026quot;2006.01.02\u0026quot; | jsonify }}, \u0026quot;body\u0026quot;: {{ $page.Plain | jsonify }} } {{ end }}]  検索処理の実装 検索処理は hugo + gruntjs + lunrjs = search にlunr.jsを使ったサンプルコードを掲載してくれている人がいて、ほぼこのままで動いた。このサンプルコードをベースに以下のカスタマイズを加えた。具体的な変更内容は Add full-text search function by koirand · Pull Request #3 · koirand/pulp を参照。\n 検索結果に本文を表示 日本語での検索対応 キーワードのハイライト  検索結果に本文を表示 本文でキーワードにヒットした箇所の前後50文字を検索結果に表示した。複数のキーワードがスペース区切りで入力された場合は先頭のキーワードだけを使っている。また、タイトルのみにヒットした場合は、本文の先頭100文字を表示している。(恐らくもっと良いやり方がある)\n日本語での検索対応 標準のlunr.jsだとスペースを単語の区切りとみなすのか日本語を検索できないので、MihaiValentin/lunr-languages: A collection of languages stemmers and stopwords for Lunr Javascript library を使う必要がある。READMEには書いてないが、日本語に対応させる場合は同封されているtinyseg.jsも読み込む必要があった。\nキーワードのハイライト キーワードのハイライトは mark.js – JavaScript keyword highlight を使うと簡単だった。\n感想 たまに一部の単語が検索にヒットしないものの、概ねちゃんと検索できてるしサクサクで良い感じ。ページの数が増えてくるとパフォーマンス落ちたりするのかなと、試しに Skycoin社のブログデータ のリポジトリをクローンしてこのテーマを適用してみたが普通にサクサク動いたので個人サイトであれば大丈夫だろう。\n追記 HUGOテーマ(pulp)の全文検索をあいまい検索に変更した - Kazuki Koide\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/async-await/",
        "title": "Promiseとasync/awaitをちゃんと理解する",
        "section": "blog",
        "date" : "2018.10.01",
        "body": " JavaScriptといえばコールバックだが、最近は基本的に非同期関数はPromiseで実装してasync/awaitするのがトレンドらしい。もし使いたい関数がPromiseをサポートしていない場合は、自分でPromiseにラップするのが良いとのこと。この辺の知識が若干怪しかったので、実際に一からやってみた。\nコールバック方式 まずは、適当に従来のコールバック方式の非同期関数を書いてみる。\n// コールバック方式による非同期関数 function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== 'number' || typeof(y) !== 'number') { callback(new Error('Invalid parameter!'), null) return } callback(null, x + y) }, 1000) } // 実行 sum(1, 2, (err, result) =\u0026gt; { if (err) { console.log(err) return } console.log('result:', result) })  sum関数は足し算をするだけの関数だが、1秒もかかってしまう。時間がかかるので非同期で動くようになっている\u0026hellip;ということにする。これを実行すると1秒後にresult: 3が出力される。引数に数値以外が指定された場合は以下のエラーが出力される。\nError: Invalid parameter! at Timeout.setTimeout [as _onTimeout] (/xxx/sandbox/nodejs/1.callback.js:4:16) at ontimeout (timers.js:498:11) at tryOnTimeout (timers.js:323:5) at Timer.listOnTimeout (timers.js:290:5)  Promise方式 次に、先ほどのsum関数をPromiseでラップする。\n// コールバック方式による非同期関数(さっきと同じもの) function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== 'number' || typeof(y) !== 'number') { callback(new Error('Invalid parameter!'), null) return } callback(null, x + y) }, 1000) } // Promiseでラップ function promiseSum (x, y) { return new Promise((resolve, reject) =\u0026gt; { sum(x, y, (err, result) =\u0026gt; { if (err) { reject(err) return } resolve(result) }) }) } // 実行 promiseSum(1, 2).then(result =\u0026gt; { console.log('result:', result) }).catch(err =\u0026gt; { console.log(err) })  これがいわゆる「Promiseでラップする」ということ。これを実行しても先ほどと同様に1秒後にresult: 3が出力される。\nコールバック方式とPromise方式の比較 コールバック方式とPromise方式の実行コードを並べてみる。\n// コールバック方式 sum(1, 2, (err, result) =\u0026gt; { if (err) { console.log(err) return } console.log('result:', result) }) // Promise方式 promiseSum(1, 2).then(result =\u0026gt; { console.log('result:', result) }).catch(err =\u0026gt; { console.log(err) })  コールバック方式の場合は、関数の仕様に合わせて例外処理する必要がある。今回だと「コールバック関数の第一引数でエラーを受け取る」という仕様だ。それがPromiseでラップすることにより、どんな関数でも同じ方法(catch)で例外処理ができる。これはPromise方式のメリットだと感じた。可読性についてはどちらも変わらないと感じる。\n非同期関数を順番に実行する 次に、1から4の数字を全て足し合わせてみる。sum関数は2つの数字しか受け取れないので、1,2の足し算の結果と3を足して、その結果と4を足すという風に順次処理を行う。それぞれ以下のようなコードになる。\nコールバック方式 // コールバック方式による非同期関数 function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== 'number' || typeof(y) !== 'number') { callback(new Error('Invalid parameter!'), null) return } callback(null, x + y) }, 1000) } // 実行 sum(1, 2, (err, result) =\u0026gt; { if (err) { console.log(err) return } sum(result, 3, (err, result) =\u0026gt; { if (err) { console.log(err) return } sum(result, 4, (err, result) =\u0026gt; { if (err) { console.log(err) return } console.log('result:', result) }) }) })  これを実行すると、足し算を３回行なっているので、３秒待ったあとにresult: 10が出力される。良くコールバック地獄やネスト地獄と言われて問題になっているが、この程度だとコールバック方式でもそこまで地獄感は感じない。地獄を味わっている人たちはどれくらい激しいネストをしているんだろうか。\nPromise方式 // コールバック方式による非同期関数 function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== 'number' || typeof(y) !== 'number') { callback(new Error('Invalid parameter!'), null) return } callback(null, x + y) }, 1000) } // Promiseでラップ function promiseSum (x, y) { return new Promise((resolve, reject) =\u0026gt; { sum(x, y, (err, result) =\u0026gt; { if (err) { reject(err) return } resolve(result) }) }) } // 実行 promiseSum(1, 2).then(result =\u0026gt; { return promiseSum(result, 3) }).then(result =\u0026gt; { return promiseSum(result, 4) }).then(result =\u0026gt; { console.log('result:', result) }).catch(err =\u0026gt; { console.log(err) })  このコードを実行した場合も、３秒待ったあとにresult: 10が出力される。Promise方式だと、メソッドチェイン的な書き方で順番に実行でき、ネストは浅くなる。またPromise方式のもうひとつのメリットとして、try catch的な例外処理ができる。個別に例外を拾いたい場合は、以下のようにthen関数の第二引数に例外処理を書くことができる。\n// 数値以外を引数に指定して故意にエラーを発生させる promiseSum('x', 2).then(result =\u0026gt; { return promiseSum(result, 3) }, () =\u0026gt; { console.log('Error handling ...') }).then(result =\u0026gt; { return promiseSum(result, 4) }).then(result =\u0026gt; { console.log('result:', result) }).catch(err =\u0026gt; { console.log(err) })  この実行結果は以下となる。\u0026rsquo;Error handling\u0026hellip;\u0026lsquo;を出力したあとcatchに飛んでいるのがわかる。\nError handling ... Error: Invalid parameter! at Timeout.setTimeout [as _onTimeout] (/xxx/sandbox/nodejs/5.secencial-promise2.js:4:16) at ontimeout (timers.js:498:11) at tryOnTimeout (timers.js:323:5) at Timer.listOnTimeout (timers.js:290:5)  async/await方式 冒頭に書いた通り、最近はasync/awaitを使うのがトレンドだ。先ほどのPromise方式を async/awaitで書き換えると以下のコードになる。\n// コールバック方式による非同期関数 function sum (x, y, callback) { setTimeout(() =\u0026gt; { if (typeof(x) !== 'number' || typeof(y) !== 'number') { callback(new Error('Invalid parameter!'), null) return } callback(null, x + y) }, 1000) } // Promiseでラップ function promiseSum (x, y) { return new Promise((resolve, reject) =\u0026gt; { sum(x, y, (err, result) =\u0026gt; { if (err) { reject(err) return } resolve(result) }) }) } // 実行 (async () =\u0026gt; { try { let result; result = await promiseSum(1, 2) result = await promiseSum(result, 3) result = await promiseSum(result, 4) console.log('result:', result) } catch (err) { console.log(err) } })()  このコードを実行した場合も3秒待ったあとにresult: 10が出力される。Promise関数にawaitを付けることで処理の完了を待ってくれる。awaitはasyncを付けたfunctionの中だけで使えるというルールがあるので即時関数を使わないといけない点はイマイチだが、コールバックを使わずに同期処理が書けるので可読性が高いと感じる。普通にtry catchで例外処理できるのもポイント高い。ちなみに先ほどのように個別で例外を拾う場合は以下のようになる。\n(async () =\u0026gt; { try { let result; // 数値以外を引数に指定して故意にエラーを発生させる result = await promiseSum('x', 2).catch(err =\u0026gt; { console.log('Error handling ...') }) result = await promiseSum(result, 3) result = await promiseSum(result, 4) await console.log('result:', result) } catch (err) { console.log(err) } })()  このように、catchで個別に例外を拾うことができる。コールバック完全駆逐\u0026hellip;とまでは行かないようだ。\nasync/await方式でのテスト 昔は、非同期処理をテストするにはco-mocha等を使った気がするが、最近はmochaでasync/awaitが使えるようだ。以下のようなテストコードになる。\ndescribe('asunc/await test', () =\u0026gt; { it('1 + 2 = 3 ', async () =\u0026gt; { const result = await promiseSum(1, 2) assert.strictEqual(result, 3) }) it('数字以外が入力されるとエラー', async () =\u0026gt; { let f = () =\u0026gt; {} try { const result = await promiseSum('x', 2) } catch (err) { f = () =\u0026gt; {throw err} } finally { assert.throws(f, 'Invalid parameter!') } }) })  "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/blog-auto-deploy/",
        "title": "ブログ(HUGO)のビルドとデプロイをCircleCIで自動化した",
        "section": "blog",
        "date" : "2018.09.30",
        "body": " このブログはHUGO(ヒューゴ)というブログ構築のためのフレームワークを使っている。HUGOで記事を作成する手順はWordPressなどのブログサイトとは異なり、PC上で静的なHTMLやCSSを生成してから、それをWebサーバにアップロードする必要がある。このブログの場合はGitHub Pagesを使っているので、Webサーバを用意しなくてもGitHubにPushすれば公開される仕組みになっているが、いずれにせよ一手間がかかる。これまでは Host on GitHub | Hugo を参考にサイトの生成とGitHubへのPushをシェルスクリプトで自動化していたが、それだったらCIツール使えばいいじゃんってことで、CircleCIでブログのデプロイを自動化することにした。\n自動化の過程 ブログの生成元となるリポジトリは非公開にしたかったのでBitbucketを使っている(GitHubはプライベートリポジトリが有料なので)。Hugo + Bitbucket + CircleCI で GitHub Pages に自動デプロイ | shotarok\u0026rsquo;s Tech Blog で既に同じ構成で自動化している人がいたのでこれを参考に構築した。ただし設定ファイルがCircleCI 1.0のものだったので、 Auto Deploy Hugo by Circle CI 2.0 - taikii blog を見ながらCircle CI 2.0を使った設定にした。Circle CIからGitHubにSSHアクセスする必要があるので、事前に鍵ペアを作成して、公開鍵をGitHubに秘密鍵をCircle CIにそれぞれ登録しておく必要があった。あとデプロイ結果をメールで確認するのが面倒だったので、CircleCI | Slack App ディレクトリ を使ってSlackで通知するようにした。\n.circleci/config.yml version: 2 jobs: build: docker: - image: cibuilds/hugo:latest environment: TZ: Asia/Tokyo working_directory: ~/blog steps: - checkout - run: name: \u0026quot;Setting for Git\u0026quot; command: | git config --global user.name \u0026quot;koirand\u0026quot; git config --global user.email \u0026quot;koirand.jp@gmail.com\u0026quot; - run: name: \u0026quot;Up to date themes\u0026quot; command: | git submodule sync git submodule update --init --recursive - run: name: \u0026quot;Get GitHub repository\u0026quot; command: git clone git@github.com:koirand/koirand.github.io.git public - run: name: \u0026quot;Build \u0026amp; Push\u0026quot; command: | hugo cd public git add . git commit -m \u0026quot;rebuilding site `date '+%Y-%m-%d'`\u0026quot; git push origin master  ビルド結果はこんな感じ。14秒くらいかかった。 2019-03-02 追記 GitHubのプライベートリポジトリが無料化されたので、ブログのリポジトリをGitHubに移行した\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/pulp/",
        "title": "HUGOのオリジナルテーマ(pulp)を作った",
        "section": "blog",
        "date" : "2018.09.29",
        "body": " このブログはHUGO(ヒューゴ)というブログ構築のためのフレームワークを使っている。HUGOはWordPressなどのブログサイトとは異なり、PC上で記事を書いてそれをHUGOを使って静的なHTMLやCSSを生成してくれる仕組みになっている。従ってWebサーバがあればどこでもアップロードして公開できる。\n The world’s fastest framework for building websites | Hugo\n 今回作ったのは、そのHUGOでHTMLやCSSを生成する際に使われるデザインテーマ。最近フロントエンドの画面を久しく作って無かったので、思い出しがてら作ってみることにした。「HUGO 自作テーマ」とかでググると作り方を解説してくれているサイトがいくつもあるし、公式ドキュメントに掲載されている動画が結構わかりやすいので、作り方については困らなかった。ちなみにこのブログはそのテーマを適用している。またURLを見ての通りGitHub Pagesで公開している。\nソースコード koirand/pulp: Pulp is a theme of Hugo framework for realize simple and readable personal blogs.\nスクリーンショット 特徴  色数を少なくして読みやすさを意識 表示媒体を選ばないデザイン 日本語対応 CSSやJSのカスタマイズ可能 コードのシンタックスハイライト対応   OGP,Twitter Card対応   一応SEOを意識して作ったけどまだ効果は不明 GoogleAnalyticsにも対応  今後やりたいこと  全文検索ができるようになるといいかな しばらく自分のブログで運用して、問題なさそうだったらHUGO公式サイトに掲載してもらう予定  "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/line-login-with-springboot/",
        "title": "SpringbootでLINEのOAuth2ログインを試した",
        "section": "blog",
        "date" : "2018.09.24",
        "body": " タイトルの通り、いわゆる「LINEでログイン」を試してみた時のメモ。\nソースコード koirand/springboot-line-login: LINE login with Springboot Sample\nOAuth2での認証方法  第1回：Spring Security 5でサポートされるOAuth 2.0 LoginをSpring Bootで使ってみる\n 主にこの記事にOAuth2クライアントの実装を行った。OAuth2でログインするためには、spring-security-oauth2-clientモジュールを使う。OpenID Connectでの認証を行う場合は加えてspring-security-oauth2-joseが必要になるが、今回はOAuth2のみなので入れなかった。\n\u0026lt;!-- OAuth2 authentication--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-oauth2-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  application.properties に以下の通りLINE用の設定を記載する。clientIDとclientSeretはLINE Developersで取得したものに書き換える。\n# Settings for LINE login spring.security.oauth2.client.registration.line.clientId={Set your client id} spring.security.oauth2.client.registration.line.clientSecret={Set your client secret} spring.security.oauth2.client.registration.line.authorizationGrantType=authorization_code spring.security.oauth2.client.registration.line.redirectUriTemplate={baseUrl}/login/oauth2/code/{registrationId} spring.security.oauth2.client.registration.line.scope=profile spring.security.oauth2.client.registration.line.clientName=LINE spring.security.oauth2.client.provider.line.authorizationUri=https://access.line.me/oauth2/v2.1/authorize spring.security.oauth2.client.provider.line.tokenUri=https://api.line.me/oauth2/v2.1/token spring.security.oauth2.client.provider.line.jwkSetUri=https://api.line.me/oauth2/v2.1/verify spring.security.oauth2.client.provider.line.userInfoUri=https://api.line.me/v2/profile spring.security.oauth2.client.provider.line.userNameAttribute=userId  Spring Securtyでは、GitHub、Google、Facebook、Oktaの４つのプロバイダに関しては、各設定値の初期値が既に設定されている。なのでapploication.propatiesにはclientIdとclientSecretだけを設定すれば動作する。例えばGitHubを追加するなら、以下の設定を追加するだけで良い。\n# Settings for GitHub login spring.security.oauth2.client.registration.github.clientId={Set your client id} spring.security.oauth2.client.registration.github.clientSecret={Set your client secret}  LINEは初期値が設定されていないので全ての設定が必要になる。scopeの種類や、各エンドポイントのURI、APIの仕様などは以下を参照。\n  ウェブアプリにLINEログインを組み込む（LINEログインv2） Social API v2.0リファレンス   LINEの場合、ユーザープロファイルを取得するためのAPI(userInfoUriで指定しているエンドポイント)のレスポンスが以下のようなJSONになる。従ってuserNameAttributeには、ユーザー名に該当するuserIdを指定している。\n{ \u0026quot;userId\u0026quot;:\u0026quot;U4af4980629...\u0026quot;, \u0026quot;displayName\u0026quot;:\u0026quot;Brown\u0026quot;, \u0026quot;pictureUrl\u0026quot;:\u0026quot;https://example.com/abcdefghijklmn\u0026quot;, \u0026quot;statusMessage\u0026quot;:\u0026quot;Hello, LINE!\u0026quot; }  ちなみにSpringboot v2.1.0.M2より古いバージョンは、userNameAttributeが反映されないので注意されたし。\n UserNameAttribute for custom OAuth2 provider by thiagohirata · Pull Request #10672 · spring-projects/spring-boot\n コントローラーのメソッドの引数に@AuthenticationPrincipalを指定することで、認証済みのユーザーの情報を受け取ることができるようになる。ここではシンプルにユーザー情報をレスポンスボディにそのままセットしている。\npackage com.example; import org.springframework.security.core.annotation.AuthenticationPrincipal; import org.springframework.security.oauth2.core.user.OAuth2User; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.bind.annotation.GetMapping; @RestController public class SampleController { @GetMapping(\u0026quot;/\u0026quot;) public Object index(@AuthenticationPrincipal OAuth2User oauth2User) { return oauth2User; } }  http://localhost:8080にアクセスすると、未認証の場合は、/loginにリダイレクトされる。/loginエンドポイントを実装していなければ、Spring SecurityのDefaultLoginPageGeneratingFilterが以下のログイン画面を自動生成する仕組みになっている。\nこの例ではLINEのみだが、複数のプロバイダを設定した場合はそれぞれのリンクが表示される。LINEリンクをクリックすると、http://localhost:8080/oauth2/authorization/lineに遷移する。自前のログインページを作成する場合は同じようにこのURIへ遷移するリンクなりボタンを作成すれば良い。http://localhost:8080/oauth2/authorization/lineにアクセスすると、そこから更にauthorizationUriで設定したhttps://access.line.me/oauth2/v2.1/authorizeへリダイレクトしてLINEの認証画面が表示される。認証に成功すると、http://localhost:8080/login/oauth2/code/lineへリダイレクトし、そして最初にアクセスしたhttp://localhost:8080へリダイレクトする。まとめると以下のようなページ遷移になる。\nhttp://localhost:8080 ↓ リダイレクト http://localhost:8080/login ↓ リンクをクリック http://localhost:8080/oauth2/authorization/line ↓ リダイレクト https://access.line.me/oauth2/v2.1/authorize ↓ 認証成功 http://localhost:8080/login/oauth2/code/line ↓ リダイレクト http://localhost:8080  なお、認証成功時のリダイレクト先のURLについては、LINE Developer画面上でホワイトリストに設定しておく必要がある。LINE以外の他のプロバイダでも同様。\n別の実装方法 LINE Engieeringブログで、spring-boot-starter-securityとspring-security-oauthを使った実現方法が紹介されていたが、この方法だとOAuth2プロバイダが１つしか指定できなかったので採用しなかった。実際はLINEだけでなくGoogleやFacebookと併用したいケースが多いのではないだろうか。\n Spring Security + 設定ファイルで始める LINE との ID Federation : LINE Engineering Blog\n "
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/tokyo-metro-vim/",
        "title": "東京メトロ配色のVimカラースキームを作った",
        "section": "blog",
        "date" : "2018.09.24",
        "body": " VimConf2017でcocoponさんがicebergというカラースキーマを作った時の話をしているのを聞いて自分もオリジナルのカラースキーマを作ってみたいと思った。東京に住んでるし東京をテーマとしたカラーススキームを作れないかとちょっと考えたものの、色彩センスに自信がなかったので、東京メトロのテーマカラーを使ってみることにした。\nソースコード koirand/tokyo-metro.vim: Vim color scheme using theme color of Tokyo Metro lines.\n作成過程 まずはPhotoshopで各路線のテーマカラーを並べた。\nダークモード派なので黒背景。思ったより見やすい印象を得た。さすが偉い人が考えた配色である。ただ千代田線と南北線の色が似ていて使い分けが難しい。カラースキームの自作方法についてWebで調べて見たところ、設定項目数が多くなかなか大変そうだったので、iceberg.vim をForkしてカスタマイズすることにした。README に記載されているが、カラースキーマを半自動生成する仕組みが提供されているのでこれを使用した。具体的な手順としては以下の通り。\n cocopon/pgmnt プラグインをVimにインストール。 src/template.vim にあるテンプレートを変更。 autoload/iceberg/palette/dark.vim をコピーして、autoload/tokyometro/palette/dark.vim を作成して、配色を変更。:source % してVimに読み込む。 src/iceberg.vim をコピーして src/tokyo-metro.vim を作成して、色と対象オブジェクトのマッピングを少し調整。cd %:hしてカレントディレクトリを変更してから:source %すると、color/tokyo-metro.vim が生成される。  できたのがこちら。 tokyo-metro - Vim Colors\n濃紺の背景は東京の夜景っぽくて違和感なかったのでオリジナルのままにした。このサンプルでは表示されてないけど、言語によっては演算子が副都心線の茶色になるはず。それから丸ノ内線については、やは赤はエラー感が強く出てしまい違和感が拭えなかったので、丸の内線ユーザーには申し訳ないが素直にエラー系の色を当てることにした。\n作ってみた感想 オリジナルカラースキームができてうれしい。cocopon/pgmnt プラグインが良く作られている。色をHSLで指定できるので、微妙な色の調整がやりやすそうに感じた。今回テーマカラーありきだったので、あまり配色には悩まなかったが、次回作るときは配色に拘ってみたい。\n"
    }
,
    {
        "ref": "https://koirand.github.io/blog/2018/post-test/",
        "title": "Post Test",
        "section": "blog",
        "date" : "2018.09.23",
        "body": " 見出し1（h1） 見出し1（h1） 見出し2（h2) 見出し2（h2） 見出し3 見出し4 見出し5 見出し6 ここは段落です。♪もーもたろさん もーもたーろさん おっこしーにつっけたーちーびまーるこー\nここは段落です。\n↑半角スペース2個で強制改行しています。\n♪もーもたろさん もーもたーろさん おっこしーにつっけたーちーんあーなごー\n 強い強調（strong）です。 これも強い強調です。 \u0026lt;strong\u0026gt;strongタグです。\u0026lt;/strong\u0026gt; 強調（em）です。 これも強調です。 斜体の\u0026lt;em\u0026gt;タグになります。 強調斜体です。 強調斜体です。 \u0026lt;strong\u0026gt;＋\u0026lt;em\u0026gt;タグになります。   引用（Blockquote）です\n 引用のネストです\n 上に一行空けないとネストのままです\n 引用（Blockquote）の中にはMarkdown要素を入れられます\n 見出し  数字リスト 数字リスト   エスケープ文字 *アスタリスクをバックスラッシュでエスケープ*\n## 見出しハッシュ文字をエスケープ\nHTMLタグをバックスラッシュでエスケープ→（\u0026lt;p\u0026gt;）\nHTMLをバッククォートでインラインコード→（\u0026lt;p\u0026gt;）\n水平線（\u0026lt;hr\u0026gt;）各種 アスタリスク3個半角スペース空けて\nアスタリスク3個以上\nハイフン半角スペース空けて\n続けてハイフン3個以上\nリスト  ハイフン箇条書きリスト プラス箇条書きリスト 米印箇条書きリスト  二階層め・箇条書きリスト  三階層め・箇条書きリスト 四階層め・箇条書きリスト   箇条書きリスト   番号付きリスト  二階層め・番号付きリスト1 二階層め・番号付きリスト2  番号付きリスト2  二階層め・番号付きリスト1  三階層め・番号付きリスト1 三階層め・番号付きリスト2 四階層め・番号付きリスト1  二階層め・番号付きリスト2  番号付きリスト3   定義リストタイトル 定義リスト要素1 定義リスト要素2 定義リスト要素3  コードブロック バッククォート or 半角チルダ3個でくくります。 ###ここにはMarkdown書式は効きません /* コメント */ testtest // コメント  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt; \u0026lt;title\u0026gt;ニョロニョロ囲みhtml\u0026lt;/title\u0026gt; /* コメント */  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt; \u0026lt;title\u0026gt;バッククォート囲みhtml\u0026lt;/title\u0026gt;  body { display: none; } /* バッククォート囲みcss */ // コメント  // 先頭に半角スペース4つでcode囲い \u0026lt;?php if (is_tag()){ $posts = query_posts($query_string . '\u0026amp;showposts=20'); } ?\u0026gt;  バッククォート1個ずつで囲むとインラインのコード（\u0026lt;code\u0026gt;\u0026lt;/code\u0026gt;）です。body { visibility: hidden; }\nリンク markdownでテキストリンク WIRED.jp\n\u0026lt;カッコ\u0026gt;でくくってリンク http://wired.jp/\n定義参照リンクです。SNSには Twitter や Facebook や Google+ などがあります。\n画像 table    Left align Right align Center align     This This This   column column column   will will will   be be be   left right center   aligned aligned aligned    （Kobitoのヘルプmdから拝借しました）\nGFM リンク URLそのまま貼り付け http://wired.jp/\n段落中の改行 ここは段落です。 ↑returnで改行しています。 ♪もーもたろさん もーもたーろさん おっこしーにつっけたーちー○○ー○○ー\nコードブロック バッククォートの開始囲みに続けて拡張子でシンタックスハイライト\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt; \u0026lt;title\u0026gt;バッククォート囲みに拡張子付きhtml\u0026lt;/title\u0026gt; /* コメント */  body { display: none; } /* コメント */  \u0026lt;?php if (is_tag()){ $posts = query_posts($query_string . '\u0026amp;showposts=20'); } ?\u0026gt;  取り消し線 取り消し線（GFM記法）\nsタグです。\n単語中のアンダースコアの無効 GitHub_Flavored_Markdown_test_test\ntasklist task1 task2 completed task  from Markdown記法 表示確認用サンプル - Qiita\n"
    }
]
